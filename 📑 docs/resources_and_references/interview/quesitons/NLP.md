## Basic NLP Interview Questions for Fresher

### 1. What is NLP?

NLP stands for ***Natural Language Processing***. The subfield of [Artificial intelligence](https://www.geeksforgeeks.org/artificial-intelligence-an-introduction/) and computational linguistics deals with the interaction between computers and human languages. It involves developing algorithms, models, and techniques to enable machines to understand, interpret, and generate natural languages in the same way as a human does.

<iframe id="google_ads_iframe_/27823234/GFG_InContent_Desktop_728x280_0" name="google_ads_iframe_/27823234/GFG_InContent_Desktop_728x280_0" title="3rd party ad content" width="728" height="188" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" aria-label="Advertisement" tabindex="0" data-load-complete="true" data-google-container-id="2" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; font-size: 17px; vertical-align: bottom; max-width: 100%;"></iframe>

NLP encompasses a wide range of tasks, including language translation, sentiment analysis, text categorization, information extraction, speech recognition, and natural language understanding. NLP allows computers to extract meaning, develop insights, and communicate with humans in a more natural and intelligent manner by processing and analyzing textual input.

### 2. What are the main challenges in NLP?

The complexity and variety of human language create numerous difficult problems for the study of Natural Language Processing (NLP). The primary challenges in NLP are as follows:

- ***Semantics and Meaning:*** It is a difficult undertaking to accurately capture the meaning of words, phrases, and sentences. The semantics of the language, including word sense disambiguation, metaphorical language, idioms, and other linguistic phenomena, must be accurately represented and understood by NLP models.
- ***Ambiguity***: Language is ambiguous by nature, with words and phrases sometimes having several meanings depending on context. Accurately resolving this ambiguity is a major difficulty for NLP systems.
- ***Contextual Understanding:*** Context is frequently used to interpret language. For NLP models to accurately interpret and produce meaningful replies, the context must be understood and used. Contextual difficulties include, for instance, comprehending referential statements and resolving pronouns to their antecedents.
- ***Language Diversity:*** NLP must deal with the world’s wide variety of languages and dialects, each with its own distinctive linguistic traits, lexicon, and grammar. The lack of resources and knowledge of low-resource languages complicates matters.
- ***Data Limitations and Bias:*** The availability of high-quality labelled data for training NLP models can be limited, especially for specific areas or languages. Furthermore, biases in training data might impair model performance and fairness, necessitating careful consideration and mitigation.
- ***Real-world Understanding:*** NLP models often fail to understand real-world knowledge and common sense, which humans are born with. Capturing and implementing this knowledge into NLP systems is a continuous problem.

### 3. What are the different tasks in NLP?

Natural Language Processing (NLP) includes a wide range of tasks involving understanding, processing, and creation of human language. Some of the most important tasks in NLP are as follows:

- [Text Classification](https://www.geeksforgeeks.org/classification-of-text-documents-using-the-approach-of-naive-bayes/)
- [Named Entity Recognition (NER)](https://www.geeksforgeeks.org/python-named-entity-recognition-ner-using-spacy/)
- [Part-of-Speech Tagging (POS)](https://www.geeksforgeeks.org/nlp-part-of-speech-default-tagging/)
- [Sentiment Analysis](https://www.geeksforgeeks.org/what-is-sentiment-analysis/)
- [Language Modeling](https://www.geeksforgeeks.org/videos/what-is-language-modelling-in-nlp/)
- [Machine Translation](https://www.geeksforgeeks.org/machine-translation-of-languages-in-artificial-intelligence/)
- [Chatbots](https://www.geeksforgeeks.org/battle-of-ai-chatbots-which-chatbot-will-rule-the-present-and-future/)
- [Text Summarization](https://www.geeksforgeeks.org/python-extractive-text-summarization-using-gensim/)
- [Information Extraction](https://www.geeksforgeeks.org/difference-between-information-retrieval-and-information-extraction/)
- [Text Generation](https://www.geeksforgeeks.org/text-generation-using-recurrent-long-short-term-memory-network/)
- [Speech Recognition](https://www.geeksforgeeks.org/text-generation-using-recurrent-long-short-term-memory-network/)

### 4. What do you mean by Corpus in NLP?

In NLP, a [corpus](https://www.geeksforgeeks.org/nlp-wordlist-corpus/) is a huge collection of texts or documents. It is a structured dataset that acts as a sample of a specific language, domain, or issue. A corpus can include a variety of texts, including books, essays, web pages, and social media posts. Corpora are frequently developed and curated for specific research or NLP objectives. They serve as a foundation for developing language models, undertaking linguistic analysis, and gaining insights into language usage and patterns.

### 5. What do you mean by text augmentation in NLP and what are the different text augmentation techniques in NLP?

[Text augmentation](https://www.geeksforgeeks.org/text-augmentation-techniques-in-nlp/) in NLP refers to the process that generates new or modified textual data from existing data in order to increase the diversity and quantity of training samples. Text augmentation techniques apply numerous alterations to the original text while keeping the underlying meaning.

Different text augmentation techniques in NLP include:

1. ***Synonym Replacement:*** Replacing words in the text with their synonyms to introduce variation while maintaining semantic similarity.
2. ***Random Insertion/Deletion:*** Randomly inserting or deleting words in the text to simulate noisy or incomplete data and enhance model robustness.
3. ***Word Swapping:*** Exchanging the positions of words within a sentence to generate alternative sentence structures.
4. ***Back translation:*** Translating the text into another language and then translating it back to the original language to introduce diverse phrasing and sentence constructions.
5. ***Random Masking:*** Masking or replacing random words in the text with a special token, akin to the approach used in masked language models like BERT.
6. ***Character-level Augmentation:*** Modifying individual characters in the text, such as adding noise, misspellings, or character substitutions, to simulate real-world variations.
7. ***Text Paraphrasing:*** Rewriting sentences or phrases using different words and sentence structures while preserving the original meaning.
8. ***Rule-based Generation:*** Applying linguistic rules to generate new data instances, such as using grammatical templates or syntactic transformations.

### 6. What are some common pre-processing techniques used in NLP?

[Natural Language Processing (NLP) ](https://www.geeksforgeeks.org/natural-language-processing-nlp-pipeline/)preprocessing refers to the set of processes and techniques used to prepare raw text input for analysis, modelling, or any other NLP tasks. The purpose of preprocessing is to clean and change text data so that it may be processed or analyzed later.

Preprocessing in NLP typically involves a series of steps, which may include:

- [Tokenization](https://www.geeksforgeeks.org/tokenize-text-using-nltk-python/)
- [Stop Word Removal](https://www.geeksforgeeks.org/removing-stop-words-nltk-python/)
- Text Normalization
  - Lowercasing
  - Lemmatization
  - Stemming
  - Date and Time Normalization
- [Removal of Special Characters and Punctuation](https://www.geeksforgeeks.org/removing-punctuations-given-string/)
- [Removing HTML Tags or Markup](https://www.geeksforgeeks.org/program-to-remove-html-tags-from-a-given-string/)
- [Spell Correction](https://www.geeksforgeeks.org/correcting-words-using-nltk-in-python/)
- [Sentence Segmentation](https://www.geeksforgeeks.org/python-perform-sentence-segmentation-using-spacy/)

### 7. What is text normalization in NLP?

Text normalization, also known as text standardization, is the process of transforming text data into a standardized or normalized form It involves applying a variety of techniques to ensure consistency,  reduce variations, and simplify the representation of textual information.

The goal of text normalization is to make text more uniform and easier to process in Natural Language Processing (NLP) tasks. Some common techniques used in text normalization include:

- ***Lowercasing***: Converting all text to lowercase to treat words with the same characters as identical and avoid duplication.
- ***Lemmatization***: Converting words to their base or dictionary form, known as lemmas. For example, converting “running” to “run” or “better” to “good.”
- ***Stemming***: Reducing words to their root form by removing suffixes or prefixes. For example, converting “playing” to “play” or “cats” to “cat.”
- ***Abbreviation Expansion***: Expanding abbreviations or acronyms to their full forms. For example, converting “NLP” to “Natural Language Processing.”
- ***Numerical Normalization***: Converting numerical digits to their written form or normalizing numerical representations. For example, converting “100” to “one hundred” or normalizing dates.
- ***Date and Time Normalization***: Standardizing date and time formats to a consistent representation.

### 8. What is tokenization in NLP?

[Tokenization](https://www.geeksforgeeks.org/tokenization-using-spacy-library/) is the process of breaking down text or string into smaller units called tokens. These tokens can be words, characters, or subwords depending on the specific applications. It is the fundamental step in many natural language processing tasks such as sentiment analysis, machine translation, and text generation. etc.

Some of the most common ways of tokenization are as follows:

- ***Sentence tokenization:*** In Sentence tokenizations, the text is broken down into individual sentences. This is one of the fundamental steps of tokenization.
- ***Word tokenization:*** In word tokenization, the text is simply broken down into words. This is one of the most common types of tokenization. It is typically done by splitting the text into spaces or punctuation marks.
- ***Subword tokenization:*** In subword tokenization, the text is broken down into subwords, which are the smaller part of words. Sometimes words are formed with more than one word, for example, Subword i.e Sub+ word, Here sub, and words have different meanings. When these two words are joined together, they form the new word “subword”, which means “a smaller unit of a word”. This is often done for tasks that require an understanding of the morphology of the text, such as stemming or lemmatization.
- ***Char-label tokenization:*** In Char-label tokenization, the text is broken down into individual characters. This is often used for tasks that require a more granular understanding of the text such as text generation, machine translations, etc.

### 9. What is NLTK and How it’s helpful in NLP?

[NLTK](https://www.geeksforgeeks.org/python-nltk-tokenize-regexp/) stands for Natural Language Processing Toolkit. It is a suite of libraries and programs written in Python Language for symbolic and statistical natural language processing. It offers tokenization, stemming, lemmatization, POS tagging, Named Entity Recognization, parsing, semantic reasoning, and classification.

NLTK is a popular NLP library for Python. It is easy to use and has a wide range of features. It is also open-source, which means that it is free to use and modify.

### 10. What is stemming in NLP, and how is it different from lemmatization?

Stemming and lemmatization are two commonly used word normalization techniques in NLP, which aim to reduce the words to their base or root word. Both have similar goals but have different approaches.

In [stemming](https://www.geeksforgeeks.org/python-stemming-words-with-nltk/), the word suffixes are removed using the heuristic or pattern-based rules regardless of the context of the parts of speech. The resulting stems may not always be actual dictionary words. Stemming algorithms are generally simpler and faster compared to lemmatization, making them suitable for certain applications with time or resource constraints.

In [lemmatization](https://www.geeksforgeeks.org/python-lemmatization-with-nltk/), The root form of the word known as lemma, is determined by considering the word’s context and parts of speech. It uses linguistic knowledge and databases (e.g., wordnet) to transform words into their root form. In this case, the output lemma is a valid word as per the dictionary. For example, lemmatizing “running” and “runner” would result in “run.” Lemmatization provides better interpretability and can be more accurate for tasks that require meaningful word representations.

### 11. How does part-of-speech tagging work in NLP?

[Part-of-speech tagging](https://www.geeksforgeeks.org/part-speech-tagging-stop-words-using-nltk-python/) is the process of assigning a part-of-speech tag to each word in a sentence. The POS tags represent the syntactic information about the words and their roles within the sentence.

There are three main approaches for POS tagging:

- ***Rule-based POS tagging:*** It uses a set of handcrafted rules to determine the part of speech based on morphological, syntactic, and contextual patterns for each word in a sentence. For example, words ending with ‘-ing’ are likely to be a verb.
- ***Statistical POS tagging:*** The statistical model like Hidden Markov Model (HMMs) or Conditional Random Fields (CRFs) are trained on a large corpus of already tagged text. The model learns the probability of word sequences with their corresponding POS tags, and it can be further used for assigning each word to a most likely POS tag based on the context in which the word appears.
- ***Neural network POS tagging:*** The neural network-based model like RNN, LSTM, Bi-directional RNN, and transformer have given promising results in POS tagging by learning the patterns and representations of words and their context.

### 12. What is named entity recognition in NLP?

[Named Entity Recognization (NER)](https://www.geeksforgeeks.org/named-entity-recognition/) is a task in natural language processing that is used to identify and classify the named entity in text. Named entity refers to real-world objects or concepts, such as persons, organizations, locations, dates, etc. NER is one of the challenging tasks in NLP because there are many different types of named entities, and they can be referred to in many different ways. The goal of NER is to extract and classify these named entities in order to offer structured data about the entities referenced in a given text.

The approach followed for Named Entity Recognization (NER) is the same as the POS tagging. The data used while training in NER is tagged with persons, organizations, locations, and dates.

### 13. What is parsing in NLP?

In NLP, [parsing](https://www.geeksforgeeks.org/difference-between-top-down-parsing-and-bottom-up-parsing/) is defined as the process of determining the underlying structure of a sentence by breaking it down into constituent parts and determining the syntactic relationships between them according to formal grammar rules. The purpose of parsing is to understand the syntactic structure of a sentence, which allows for deeper learning of its meaning and encourages different downstream NLP tasks such as semantic analysis, information extraction, question answering, and machine translation. it is also known as syntax analysis or syntactic parsing.

The formal grammar rules used in parsing are typically based on Chomsky’s hierarchy. The simplest grammar in the Chomsky hierarchy is regular grammar, which can be used to describe the syntax of simple sentences. More complex grammar, such as context-free grammar and context-sensitive grammar, can be used to describe the syntax of more complex sentences.

### 14. What are the different types of parsing in NLP?

In natural language processing (NLP), there are several types of parsing algorithms used to analyze the grammatical structure of sentences. Here are some of the main types of parsing algorithms:

- [***Constituency Parsing***](https://www.geeksforgeeks.org/constituency-parsing-and-dependency-parsing/): Constituency parsing in NLP tries to figure out a sentence’s hierarchical structure by breaking it into constituents based on a particular grammar. It generates valid constituent structures using context-free grammar. The parse tree that results represents the structure of the sentence, with the root node representing the complete sentence and internal nodes representing phrases. Constituency parsing techniques like as CKY, Earley, and chart parsing are often used for parsing. This approach is appropriate for tasks that need a thorough comprehension of sentence structure, such as semantic analysis and machine translation. When a complete understanding of sentence structure is required, constituency parsing, a classic parsing approach, is applied.
- [***Dependency Parsing***](https://www.geeksforgeeks.org/constituency-parsing-and-dependency-parsing/)***:*** In NLP, dependency parsing identifies grammatical relationships between words in a sentence. It represents the sentence as a directed graph, with dependencies shown as labelled arcs. The graph emphasises subject-verb, noun-modifier, and object-preposition relationships. The head of a dependence governs the syntactic properties of another word. Dependency parsing, as opposed to constituency parsing, is helpful for languages with flexible word order. It allows for the explicit illustration of word-to-word relationships, resulting in a clear representation of grammatical structure.
- [***Top-down parsing:***](https://www.geeksforgeeks.org/difference-between-top-down-parsing-and-bottom-up-parsing/) Top-down parsing starts at the root of the parse tree and iteratively breaks down the sentence into smaller and smaller parts until it reaches the leaves. This is a more natural technique for parsing sentences. However, because it requires a more complicated language, it may be more difficult to implement.
- [***Bottom-up parsing:***](https://www.geeksforgeeks.org/difference-between-top-down-parsing-and-bottom-up-parsing/) Bottom-up parsing starts with the leaves of the parse tree and recursively builds up the tree from smaller and smaller constituents until it reaches the root. Although this method of parsing requires simpler grammar, it is frequently simpler to implement, even when it is less understandable.

### 15. What do you mean by vector space in NLP?

 In natural language processing (NLP), A [vector space](https://www.geeksforgeeks.org/web-information-retrieval-vector-space-model/) is a mathematical vector where words or documents are represented by numerical vectors form. The word or document’s specific features or attributes are represented by one of the dimensions of the vector. Vector space models are used to convert text into numerical representations that machine learning algorithms can understand.

Vector spaces are generated using techniques such as word embeddings, bag-of-words, and term frequency-inverse document frequency (TF-IDF). These methods allow for the conversion of textual data into dense or sparse vectors in a high-dimensional space. Each dimension of the vector may indicate a different feature, such as the presence or absence of a word, word frequency, semantic meaning, or contextual information.

### 16. What is the bag-of-words model?

[Bag of Words](https://www.geeksforgeeks.org/bag-of-words-bow-model-in-nlp/) is a classical text representation technique in NLP that describes the occurrence of words within a document or not. It just keeps track of word counts and ignores the grammatical details and the word order.

Each document is transformed as a numerical vector, where each dimension corresponds to a unique word in the vocabulary. The value in each dimension of the vector represents the frequency, occurrence, or other measure of importance of that word in the document.

```
Let's consider two simple text documents:
Document 1: "I love apples."
Document 2: "I love mangoes too."

Step 1: Tokenization
Document 1 tokens: ["I", "love", "apples"]
Document 2 tokens: ["I", "love", "mangoes", "too"]

Step 2: Vocabulary Creation by collecting all unique words across the documents
Vocabulary: ["I", "love", "apples", "mangoes", "too"]
The vocabulary has five unique words, so each document vector will have five dimensions.

Step 3: Vectorization
Create numerical vectors for each document based on the vocabulary.
For Document 1:
- The dimension corresponding to "I" has a value of 1.
- The dimension corresponding to "love" has a value of 1.
- The dimension corresponding to "apples" has a value of 1.
- The dimensions corresponding to "mangoes" and "too" have values of 0 since they do not appear in Document 1.
Document 1 vector: [1, 1, 1, 0, 0]

For Document 2:
- The dimension corresponding to "I" has a value of 1.
- The dimension corresponding to "love" has a value of 1.
- The dimension corresponding to "mangoes" has a value of 1.
- The dimension corresponding to "apples" has a value of 0 since it does not appear in Document 2.
- The dimension corresponding to "too" has a value of 1.
Document 2 vector: [1, 1, 0, 1, 1]
```

The value in each dimension represents the occurrence or frequency of the corresponding word in the document. The BoW representation allows us to compare and analyze the documents based on their word frequencies.

### 17. Define the Bag of N-grams model in NLP.

The [Bag of n-grams](https://www.geeksforgeeks.org/n-gram-language-modelling-with-nltk/) model is a modification of the standard bag-of-words (BoW) model in NLP. Instead of taking individual words to be the fundamental units of representation, the Bag of n-grams model considers contiguous sequences of n words, known as n-grams, to be the fundamental units of representation.

The Bag of n-grams model divides the text into n-grams, which can represent consecutive words or characters depending on the value of n. These n-grams are subsequently considered as features or tokens, similar to individual words in the BoW model.

The steps for creating a bag-of-n-grams model are as follows:

- The text is split or tokenized into individual words or characters.
- The tokenized text is used to construct N-grams of size n (sequences of n consecutive words or characters). If n is set to 1 known as uni-gram i.e. same as a bag of words, 2 i.e. bi-grams, and 3 i.e. tri-gram.
- A vocabulary is built by collecting all unique n-grams across the entire corpus.
- Similarly to the BoW approach, each document is represented as a numerical vector. The vector’s dimensions correspond to the vocabulary’s unique n-grams, and the value in each dimension denotes the frequency or occurrence of that n-gram in the document.

### 18. What is the term frequency-inverse document frequency (TF-IDF)?

[Term frequency-inverse document frequency (TF-IDF) ](https://www.geeksforgeeks.org/understanding-tf-idf-term-frequency-inverse-document-frequency/)is a classical text representation technique in NLP that uses a statistical measure to evaluate the importance of a word in a document relative to a corpus of documents. It is a combination of two terms: term frequency (TF) and inverse document frequency (IDF).

- ***Term Frequency (TF):*** Term frequency measures how frequently a word appears in a document. it is the ratio of the number of occurrences of a term or word (t ) in a given document (d) to the total number of terms in a given document (d). A higher term frequency indicates that a word is more important within a specific document.
- ***Inverse Document Frequency (IDF):*** Inverse document frequency measures the rarity or uniqueness of a term across the entire corpus. It is calculated by taking the logarithm of the ratio of the total number of documents in the corpus to the number of documents containing the term. it down the weight of the terms, which frequently occur in the corpus, and up the weight of rare terms.

The TF-IDF score is calculated by multiplying the term frequency (TF) and inverse document frequency (IDF) values for each term in a document. The resulting score indicates the term’s importance in the document and corpus. Terms that appear frequently in a document but are uncommon in the corpus will have high TF-IDF scores, suggesting their importance in that specific document.

### 19. Explain the concept of cosine similarity and its importance in NLP.

The similarity between two vectors in a multi-dimensional space is measured using the cosine similarity metric. To determine how similar or unlike the vectors are to one another, it calculates the cosine of the angle between them.

In natural language processing (NLP), [Cosine similarity](https://www.geeksforgeeks.org/cosine-similarity/) is used to compare two vectors that represent text. The degree of similarity is calculated using the cosine of the angle between the document vectors. To compute the cosine similarity between two text document vectors, we often used the following procedures:

- Text Representation: Convert text documents into numerical vectors using approaches like bag-of-words, TF-IDF (Term Frequency-Inverse Document Frequency), or word embeddings like Word2Vec or GloVe.
- Vector Normalization: Normalize the document vectors to unit length. This normalization step ensures that the length or magnitude of the vectors does not affect the cosine similarity calculation.
- Cosine Similarity Calculation: Take the dot product of the normalised vectors and divide it by the product of the magnitudes of the vectors to obtain the cosine similarity.

Mathematically, the cosine similarity between two document vectors, ![\vec{a}       ](https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-3d808398906456d730f9a7854b217ce1_l3.svg)and ![\vec{b}       ](https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-cf36f04bdadabcc529bbb8b2236430c7_l3.svg), can be expressed as:

![\text{Cosine Similarity}(\vec{a},\vec{b}) = \frac{\vec{a}\cdot \vec{b}}{\left | \vec{a} \right |\left | \vec{b} \right |}     ](https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-bf90f0e23ed620066f7e328095a5ab37_l3.svg)

Here,

<iframe id="google_ads_iframe_/27823234/gfg_outstream_incontent_5_0" name="google_ads_iframe_/27823234/gfg_outstream_incontent_5_0" title="3rd party ad content" width="728" height="280" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" aria-label="Advertisement" tabindex="0" data-load-complete="true" data-google-container-id="d" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; font-size: 17px; vertical-align: bottom; max-width: 100%;"></iframe>

- ![\vec{a}\cdot\vec{b}       ](https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-5a5de1cf051986fd86f06ce32273f4ff_l3.svg)is the dot product of vectors a and b
- |a| and |b| represent the Euclidean norms (magnitudes) of vectors a and b, respectively.

The resulting cosine similarity score ranges from -1 to 1, where 1 represents the highest similarity, 0 represents no similarity, and -1 represents the maximum dissimilarity between the documents.

### 20. What are the differences between rule-based, statistical-based and neural-based approaches in NLP?

[Natural language processing (NLP)](https://www.geeksforgeeks.org/natural-language-processing-nlp-pipeline/) uses three distinct approaches to tackle language understanding and processing tasks: rule-based, statistical-based, and neural-based.

1. **Rule-based Approach:** 

   Rule-based systems rely on predefined sets of linguistic rules and patterns to analyze and process language. 

   - Linguistic Rules are manually crafted rules by human experts to define patterns or grammar structures.
   - The knowledge in rule-based systems is explicitly encoded in the rules, which may cover syntactic, semantic, or domain-specific information.
   - Rule-based systems offer high interpretability as the rules are explicitly defined and understandable by human experts.
   - These systems often require manual intervention and rule modifications to handle new language variations or domains.

2. **Statistical-based Approach:** 

   Statistical-based systems utilize statistical algorithms and models to learn patterns and structures from large datasets.

   - By examining the data’s statistical patterns and relationships, these systems learn from training data.
   - Statistical models are more versatile than rule-based systems because they can train on relevant data from various topics and languages.

3. **Neural-based Approach:**

    

   Neural-based systems employ deep learning models, such as neural networks, to learn representations and patterns directly from raw text data.

   - Neural networks learn hierarchical representations of the input text, which enable them to capture complex language features and semantics.
   - Without explicit rule-making or feature engineering, these systems learn directly from data.
   - By training on huge and diverse datasets, neural networks are very versatile and can perform a wide range of NLP tasks.
   - In many NLP tasks, neural-based models have attained state-of-the-art performance, outperforming classic rule-based or statistical-based techniques.

### 21. What do you mean by Sequence in the Context of NLP?

A Sequence primarily refers to the sequence of elements that are analyzed or processed together. In [NLP](https://www.geeksforgeeks.org/natural-language-processing-nlp-pipeline/), a sequence may be a sequence of characters, a sequence of words or a sequence of sentences.

In general, sentences are often treated as sequences of words or tokens. Each word in the sentence is considered an element in the sequence. This sequential representation allows for the analysis and processing of sentences in a structured manner, where the order of words matters.

By considering sentences as sequences, NLP models can capture the contextual information and dependencies between words, enabling tasks such as part-of-speech tagging, named entity recognition, sentiment analysis, machine translation, and more.

### 22. What are the various types of machine learning algorithms used in NLP?

There are various types of machine learning algorithms that are often employed in natural language processing (NLP) tasks. Some of them are as follows:

- [Naive Bayes:](https://www.geeksforgeeks.org/naive-bayes-classifiers/) Naive Bayes is a probabilistic technique that is extensively used in NLP for text classification tasks. It computes the likelihood of a document belonging to a specific class based on the presence of words or features in the document.
- [Support Vector Machines (SVM)](https://www.geeksforgeeks.org/support-vector-machine-algorithm/): SVM is a supervised learning method that can be used for text classification, sentiment analysis, and named entity recognition. Based on the given set of features, SVM finds a hyperplane that splits data points into various classes.
- [Decision Trees:](https://www.geeksforgeeks.org/decision-tree/) Decision trees are commonly used for tasks such as sentiment analysis, and information extraction. These algorithms build a tree-like model based on an order of decisions and feature conditions, which helps in making predictions or classifications.
- [Random Forests:](https://www.geeksforgeeks.org/random-forest-classifier-using-scikit-learn/) Random forests are a type of ensemble learning that combines multiple decision trees to improve accuracy and reduce overfitting. They can be applied to the tasks like text classification, named entity recognition, and sentiment analysis.
- [Recurrent Neural Networks (RNN):](https://www.geeksforgeeks.org/introduction-to-recurrent-neural-network/) RNNs are a type of neural network architecture that are often used in sequence-based NLP tasks like language modelling, machine translation, and sentiment analysis. RNNs can capture temporal dependencies and context within a word sequence.
- [Long Short-Term Memory (LSTM)](https://www.geeksforgeeks.org/long-short-term-memory-lstm-rnn-in-tensorflow/): LSTMs are a type of recurrent neural network that was developed to deal with the vanishing gradient problem of RNN. LSTMs are useful for capturing long-term dependencies in sequences, and they have been used in applications such as machine translation, named entity identification, and sentiment analysis.
- [Transformer](https://www.geeksforgeeks.org/transformer-neural-network-in-deep-learning-overview/): Transformers are a relatively recent architecture that has gained significant attention in NLP. By exploiting self-attention processes to capture contextual relationships in text, transformers such as the BERT (Bidirectional Encoder Representations from Transformers) model have achieved state-of-the-art performance in a wide range of NLP tasks.

### 23. What is Sequence Labelling in NLP?

Sequence labelling is one of the fundamental NLP tasks in which, categorical labels are assigned to each individual element in a sequence. The sequence can represent various linguistic units such as words, characters, sentences, or paragraphs.

Sequence labelling in NLP includes the following tasks.

- Part-of-Speech Tagging (POS Tagging): In which part-of-speech tags (e.g., noun, verb, adjective) are assigned to each word in a sentence.
- Named Entity Recognition (NER): In which named entities like person names, locations, organizations, or dates are recognized and tagged in the sentences.
- Chunking: Words are organized into syntactic units or “chunks” based on their grammatical roles (for example, noun phrase, verb phrase).
- Semantic Role Labeling (SRL): In which, words or phrases in a sentence are labelled based on their semantic roles like Teacher, Doctor, Engineer, Lawyer etc
- Speech Tagging: In speech processing tasks such as speech recognition or phoneme classification, labels are assigned to phonetic units or acoustic segments.

Machine learning models like Conditional Random Fields (CRFs), Hidden Markov Models (HMMs), recurrent neural networks (RNNs), or transformers are used for sequence labelling tasks. These models learn from the labelled training data to make predictions on unseen data.

### 24.What is topic modelling in NLP?

Topic modelling is Natural Language Processing task used to discover hidden topics from large text documents. It is an unsupervised technique, which takes unlabeled text data as inputs and applies the probabilistic models that represent the probability of each document being a mixture of topics. For example, A document could have a 60% chance of being about neural networks, a 20% chance of being about Natural Language processing, and a 20% chance of being about anything else.

Where each topic will be distributed over words means each topic is a list of words, and each word has a probability associated with it. and the words that have the highest probabilities in a topic are the words that are most likely to be used to describe that topic. For example, the words like “neural”, “RNN”, and “architecture” are the keywords for neural networks and the words like ‘language”, and “sentiment” are the keywords for Natural Language processing.

There are a number of topic modelling algorithms but two of the most popular topic modelling algorithms are as follows:

- [***Latent Dirichlet Allocation (LDA)***](https://www.geeksforgeeks.org/latent-dirichlet-allocation/)***:*** LDA is based on the idea that each text in the corpus is a mash-up of various topics and that each word in the document is derived from one of those topics. It is assumed that there is an unobservable (latent) set of topics and each document is generated by Topic Selection or Word Generation.
- [***Non-Negative Matrix Factorization (NMF)***](https://www.geeksforgeeks.org/non-negative-matrix-factorization/)***:*** NMF is a matrix factorization technique that approximates the term-document matrix (where rows represent documents and columns represent words) into two non-negative matrices: one representing the topic-word relationships and the other the document-topic relationships. NMF aims to identify representative topics and weights for each document.

Topic modelling is especially effective for huge text collections when manually inspecting and categorising each document would be impracticable and time-consuming. We can acquire insights into the primary topics and structures of text data by using topic modelling, making it easier to organise, search, and analyse enormous amounts of unstructured text.

### 25. What is the GPT?

[GPT](https://www.geeksforgeeks.org/gpt-4-vs-gpt-3/) stands for “Generative Pre-trained Transformer”. It refers to a collection of large language models created by OpenAI. It is trained on a massive dataset of text and code, which allows it to generate text, generate code, translate languages, and write many types of creative content, as well as answer questions in an informative manner. The GPT series includes various models, the most well-known and commonly utilised of which are the GPT-2 and GPT-3.

GPT models are built on the Transformer architecture, which allows them to efficiently capture long-term dependencies and contextual information in text. These models are pre-trained on a large corpus of text data from the internet, which enables them to learn the underlying patterns and structures of language.



## Advanced NLP Interview Questions for Experienced

### 26. What are word embeddings in NLP?

[Word embeddings](https://www.geeksforgeeks.org/word-embeddings-in-nlp/) in NLP are defined as the dense, low-dimensional vector representations of words that capture semantic and contextual information about words in a language. It is trained using big text corpora through unsupervised or supervised methods to represent words in a numerical format that can be processed by machine learning models.

The main goal of Word embeddings is to capture relationships and similarities between words by representing them as dense vectors in a continuous vector space. These vector representations are acquired using the distributional hypothesis, which states that words with similar meanings tend to occur in similar contexts. Some of the popular pre-trained word embeddings are Word2Vec, GloVe (Global Vectors for Word Representation), or FastText. The advantages of word embedding over the traditional text vectorization technique are as follows:

- It can capture the Semantic Similarity between the words
- It is capable of capturing syntactic links between words. Vector operations such as “king” – “man” + “woman” may produce a vector similar to the vector for “queen,” capturing the gender analogy.
- Compared to one-shot encoding, it has reduced the dimensionality of word representations. Instead of high-dimensional sparse vectors, word embeddings typically have a fixed length and represent words as dense vectors.
- It can be generalized to represent words that they have not been trained on i.e. out-of-vocabulary words. This is done by using the learned word associations to place new words in the vector space near words that they are semantically or syntactically similar to.

### 27. What are the various algorithms used for training word embeddings?

There are various approaches that are typically used for training word embeddings, which are dense vector representations of words in a continuous vector space. Some of the popular word embedding algorithms are as follows:

- ***Word2Vec***

  : Word2vec is a common approach for generating vector representations of words that reflect their meaning and relationships. Word2vec learns embeddings using a shallow neural network and follows two approaches: CBOW and Skip-gram

  - CBOW (Continuous Bag-of-Words) predicts a target word based on its context words.
  - Skip-gram predicts context words given a target word.

- ***GloVe***: GloVe (Global Vectors for Word Representation) is a word embedding model that is similar to Word2vec. GloVe, on the other hand, uses  objective function that constructs a co-occurrence matrix based on the statistics of word co-occurrences in a large corpus. The co-occurrence matrix is a square matrix where each entry represents the number of times two words co-occur in a window of a certain size. GloVe then performs matrix factorization on the co-occurrence matrix. Matrix factorization is a technique for finding a low-dimensional representation of a high-dimensional matrix. In the case of GloVe, the low-dimensional representation is a vector representation for each word in the corpus. The word embeddings are learned by minimizing a loss function that measures the difference between the predicted co-occurrence probabilities and the actual co-occurrence probabilities. This makes GloVe more robust to noise and less sensitive to the order of words in a sentence.

- [***FastText***](https://www.geeksforgeeks.org/fasttext-working-and-implementation/): FastText is a Word2vec extension that includes subword information. It represents words as bags of character n-grams, allowing it to handle out-of-vocabulary terms and capture morphological information. During training, FastText considers subword information as well as word context..

- [***ELMo***](https://www.geeksforgeeks.org/overview-of-word-embedding-using-embeddings-from-language-models-elmo/): ELMo is a deeply contextualised word embedding model that generates context-dependent word representations. It generates word embeddings that capture both semantic and syntactic information based on the context of the word using bidirectional language models.

- [***BERT***](https://www.geeksforgeeks.org/explanation-of-bert-model-nlp/): A transformer-based model called BERT (Bidirectional Encoder Representations from Transformers) learns contextualised word embeddings. BERT is trained on a large corpus by anticipating masked terms inside a sentence and gaining knowledge about the bidirectional context. The generated embeddings achieve state-of-the-art performance in many NLP tasks and capture extensive contextual information.

### 28. How to handle out-of-vocabulary (OOV) words in NLP?

OOV words are words that are missing in a language model’s vocabulary or the training data it was trained on. Here are a few approaches to handling OOV words in NLP:

<iframe id="google_ads_iframe_/27823234/gfg_outstream_incontent_6_0" name="google_ads_iframe_/27823234/gfg_outstream_incontent_6_0" title="3rd party ad content" width="728" height="280" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" aria-label="Advertisement" tabindex="0" data-load-complete="true" data-google-container-id="e" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; font-size: 17px; vertical-align: bottom; max-width: 100%;"></iframe>

1. ***Character-level models:*** Character-level models can be used in place of word-level representations. In this method, words are broken down into individual characters, and the model learns representations based on character sequences. As a result, the model can handle OOV words since it can generalize from known character patterns.
2. ***Subword tokenization:*** Byte-Pair Encoding (BPE) and WordPiece are two subword tokenization algorithms that divide words into smaller subword units based on their frequency in the training data. This method enables the model to handle OOV words by representing them as a combination of subwords that it comes across during training.
3. ***Unknown token:*** Use a special token, frequently referred to as an “unknown” token or “UNK,” to represent any OOV term that appears during inference. Every time the model comes across an OOV term, it replaces it with the unidentified token and keeps processing. The model is still able to generate relevant output even though this technique doesn’t explicitly define the meaning of the OOV word. 
4. ***External knowledge:*** When dealing with OOV terms, using external knowledge resources, like a knowledge graph or an external dictionary, can be helpful. We need to try to look up a word’s definition or relevant information in the external knowledge source when we come across an OOV word.
5. ***Fine-tuning:*** We can fine-tune using the pre-trained language model with domain-specific or task-specific data that includes OOV words. By incorporating OOV words in the fine-tuning process, we expose the model to these words and increase its capacity to handle them.

### 29. What is the difference between a word-level and character-level language model?

The main difference between a word-level and a character-level language model is how text is represented. A character-level language model represents text as a sequence of characters, whereas a word-level language model represents text as a sequence of words.

Word-level language models are often easier to interpret and more efficient to train. They are, however, less accurate than character-level language models because they cannot capture the intricacies of the text that are stored in the character order. Character-level language models are more accurate than word-level language models, but they are more complex to train and interpret. They are also more sensitive to noise in the text, as a slight alteration in a character can have a large impact on the meaning of the text.

The key differences between word-level and character-level language models are:

|                                  |                         Word-level                         |                       Character-level                        |
| :------------------------------: | :--------------------------------------------------------: | :----------------------------------------------------------: |
|       Text representation        |                     Sequence of words                      |                    Sequence of characters                    |
|         Interpretability         |                    Easier to interpret                     |                 More difficult to interpret                  |
|       Sensitivity to noise       |                       Less sensitive                       |                        More sensitive                        |
|            Vocabulary            |                 Fixed vocabulary of words                  |                   No predefined vocabulary                   |
| Out-of-vocabulary (OOV) handling |                  Struggles with OOV words                  |                 Naturally handles OOV words                  |
|          Generalization          |       Captures semantic relationships between words        |           Better at handling morphological details           |
|       Training complexity        | Smaller input/output space, less computationally intensive |  Larger input/output space, more computationally intensive   |
|           Applications           |  Well-suited for tasks requiring word-level understanding  | Suitable for tasks requiring fine-grained details or morphological variations |

### 30. What is word sense disambiguation?

The task of determining which sense of a word is intended in a given context is known as [word sense disambiguation (WSD)](https://www.geeksforgeeks.org/word-sense-disambiguation-in-natural-language-processing/). This is a challenging task because many words have several meanings that can only be determined by considering the context in which the word is used.

For example, the word “bank” can be used to refer to a variety of things, including “a financial institution,” “a riverbank,” and “a slope.” The term “bank” in the sentence “I went to the bank to deposit my money” should be understood to mean “a financial institution.” This is so because the sentence’s context implies that the speaker is on their way to a location where they can deposit money.

### 31. What is co-reference resolution?

Co-reference resolution is a natural language processing (NLP) task that involves identifying all expressions in a text that refer to the same entity. In other words, it tries to determine whether words or phrases in a text, typically pronouns or noun phrases, correspond to the same real-world thing. For example, the pronoun “he” in the sentence “Pawan Gunjan has compiled this article, He had done lots of research on Various NLP interview questions” refers to Pawan Gunjan himself. Co-reference resolution automatically identifies such linkages and establishes that “He” refers to “Pawan Gunjan” in all instances.

Co-reference resolution is used in information extraction, question answering, summarization, and dialogue systems because it helps to generate more accurate and context-aware representations of text data. It is an important part of systems that require a more in-depth understanding of the relationships between entities in large text corpora.

### 32.What is information extraction?

[Information extraction](https://www.geeksforgeeks.org/difference-between-information-retrieval-and-information-extraction/) is a natural language processing task used to extract specific pieces of information like names, dates, locations, and relationships etc from unstructured or semi-structured texts.

Natural language is often ambiguous and can be interpreted in a variety of ways, which makes IE a difficult process. Some of the common techniques used for information extraction include:

- ***Named entity recognition (NER):*** In NER, named entities like people, organizations, locations, dates, or other specific categories are recognized from the text documents. For NER problems, a variety of machine learning techniques, including conditional random fields (CRF), support vector machines (SVM), and deep learning models, are frequently used.
- ***Relationship extraction:*** In relationship extraction, the connections between the stated text are identified. I figure out the relations different kinds of relationships between various things like “is working at”, “lives in” etc.
- ***Coreference resolution:*** Coreference resolution is the task of identifying the referents of pronouns and other anaphoric expressions in the text. A coreference resolution system, for example, might be able to figure out that the pronoun “he” in a sentence relates to the person “John” who was named earlier in the text.
- ***Deep Learning-based Approaches:*** To perform information extraction tasks, deep learning models such as recurrent neural networks (RNNs), transformer-based architectures (e.g., BERT, GPT), and deep neural networks have been used. These models can learn patterns and representations from data automatically, allowing them to manage complicated and diverse textual material.

### 33. What is the Hidden Markov Model, and How it’s helpful in NLP tasks?

[Hidden Markov Model](https://www.geeksforgeeks.org/hidden-markov-model-in-machine-learning/) is a probabilistic model based on the Markov Chain Rule used for modelling sequential data like characters, words, and sentences by computing the probability distribution of sequences.

Markov chain uses the Markov assumptions which state that the probabilities future state of the system only depends on its present state, not on any past state of the system. This assumption simplifies the modelling process by reducing the amount of information needed to predict future states.

The underlying process in an HMM is represented by a set of hidden states that are not directly observable. Based on the hidden states, the observed data, such as characters, words, or phrases, are generated.

Hidden Markov Models consist of two key components:

1. Transition Probabilities: The transition probabilities in Hidden Markov Models(HMMs) represents the likelihood of moving from one hidden state to another. It captures the dependencies or relationships between adjacent states in the sequence. In part-of-speech tagging, for example, the HMM’s hidden states represent distinct part-of-speech tags, and the transition probabilities indicate the likelihood of transitioning from one part-of-speech tag to another.
2. Emission Probabilities: In HMMs, emission probabilities define the likelihood of observing specific symbols (characters, words, etc.) given a particular hidden state. The link between the hidden states and the observable symbols is encoded by these probabilities.
3. Emission probabilities are often used in NLP to represent the relationship between words and linguistic features such as part-of-speech tags or other linguistic variables. The HMM captures the likelihood of generating an observable symbol (e.g., word) from a specific hidden state (e.g., part-of-speech tag) by calculating the emission probabilities.

Hidden Markov Models (HMMs) estimate transition and emission probabilities from labelled data using approaches such as the Baum-Welch algorithm. Inference algorithms like Viterbi and Forward-Backward are used to determine the most likely sequence of hidden states given observed symbols. HMMs are used to represent sequential data and have been implemented in NLP applications such as part-of-speech tagging. However, advanced models, such as CRFs and neural networks, frequently beat HMMs due to their flexibility and ability to capture richer dependencies.

### 34. What is the conditional random field (CRF) model in NLP?

[Conditional Random Fields](https://www.geeksforgeeks.org/conditional-random-fields-crfs-for-pos-tagging-in-nlp/) are a probabilistic graphical model that is designed to predict the sequence of labels for a given sequence of observations. It is well-suited for prediction tasks in which contextual information or dependencies among neighbouring elements are crucial.

CRFs are an extension of Hidden Markov Models (HMMs) that allow for the modelling of more complex relationships between labels in a sequence. It is specifically designed to capture dependencies between non-consecutive labels, whereas HMMs presume a Markov property in which the current state is only dependent on the past state. This makes CRFs more adaptable and suitable for capturing long-term dependencies and complicated label interactions.

In a CRF model, the labels and observations are represented as a graph. The nodes in the graph represent the labels, and the edges represent the dependencies between the labels. The model assigns weights to features that capture relevant information about the observations and labels.

During training, the CRF model learns the weights by maximizing the conditional log-likelihood of the labelled training data. This process involves optimization algorithms such as gradient descent or the iterative scaling algorithm.

During inference, given an input sequence, the CRF model calculates the conditional probabilities of different label sequences. Algorithms like the Viterbi algorithm efficiently find the most likely label sequence based on these probabilities.

CRFs have demonstrated high performance in a variety of sequence labelling tasks like named entity identification, part-of-speech tagging, and others.

<iframe id="google_ads_iframe_/27823234/gfg_outstream_incontent_7_0" name="google_ads_iframe_/27823234/gfg_outstream_incontent_7_0" title="3rd party ad content" width="728" height="280" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" aria-label="Advertisement" tabindex="0" data-load-complete="true" data-google-container-id="f" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; font-size: 17px; vertical-align: bottom; max-width: 100%;"></iframe>

### 35. What is a recurrent neural network (RNN)?

[Recurrent Neural Networks](https://www.geeksforgeeks.org/introduction-to-recurrent-neural-network/) are the type of artificial neural network that is specifically built to work with sequential or time series data. It is utilised in natural language processing activities such as language translation, speech recognition, sentiment analysis, natural language production, summary writing, and so on. It differs from feedforward neural networks in that the input data in RNN does not only flow in a single direction but also has a loop or cycle inside its design that has “memory” that preserves information over time. As a result, the RNN can handle data where context is critical, such as natural languages.

RNNs work by analysing input sequences one element at a time while keeping track in a hidden state that provides a summary of the sequence’s previous elements. At each time step, the hidden state is updated based on the current input and the prior hidden state. RNNs can thus capture the temporal connections between sequence items and use that knowledge to produce predictions.

### 36. How does the Backpropagation through time work in RNN?

[Backpropagation through time(BPTT)](https://www.geeksforgeeks.org/ml-back-propagation-through-time/) propagates gradient information across the RNN’s recurrent connections over a sequence of input data. Let’s understand step by step process for BPTT.

1. Forward Pass: The input sequence is fed into the RNN one element at a time, starting from the first element. Each input element is processed through the recurrent connections, and the hidden state of the RNN is updated.
2. Hidden State Sequence: The hidden state of the RNN is maintained and carried over from one time step to the next. It contains information about the previous inputs and hidden states in the sequence.
3. Output Calculation: The updated hidden state is used to compute the output at each time step.
4. Loss Calculation: At the end of the sequence, the predicted output is compared to the target output, and a loss value is calculated using a suitable loss function, such as mean squared error or cross-entropy loss.
5. Backpropagation: The loss is then backpropagated through time, starting from the last time step and moving backwards in time. The gradients of the loss with respect to the parameters of the RNN are calculated at each time step.
6. Weight Update: The gradients are accumulated over the entire sequence, and the weights of the RNN are updated using an optimization algorithm such as gradient descent or its variants.
7. Repeat: The process is repeated for a specified number of epochs or until convergence, during this the training data is iterated through several times.

During the backpropagation step, the gradients at each time step are obtained and used to update the weights of the recurrent connections. This accumulation of gradients over numerous time steps allows the RNN to learn and capture dependencies and patterns in sequential data.

### 37. What are the limitations of a standard RNN?

Standard [RNNs (Recurrent Neural Networks)](https://www.geeksforgeeks.org/introduction-to-recurrent-neural-network/) have several limitations that can make them unsuitable for certain applications:

1. Vanishing Gradient Problem: Standard RNNs are vulnerable to the vanishing gradient problem, in which gradients decrease exponentially as they propagate backwards through time. Because of this issue, it is difficult for the network to capture and transmit long-term dependencies across multiple time steps during training.
2. Exploding Gradient Problem: RNNs, on the other hand, can suffer from the expanding gradient problem, in which gradients get exceedingly big and cause unstable training. This issue can cause the network to converge slowly or fail to converge at all.
3. Short-Term Memory: Standard RNNs have limited memory and fail to remember information from previous time steps. Because of this limitation, they have difficulty capturing long-term dependencies in sequences, limiting their ability to model complicated relationships that span a significant number of time steps.

### 38. What is a long short-term memory (LSTM) network?

A [Long Short-Term Memory (LSTM)](https://www.geeksforgeeks.org/long-short-term-memory-lstm-rnn-in-tensorflow/) network is a type of recurrent neural network (RNN) architecture that is designed to solve the vanishing gradient problem and capture long-term dependencies in sequential data. LSTM networks are particularly effective in tasks that involve processing and understanding sequential data, such as natural language processing and speech recognition.

The key idea behind LSTMs is the integration of a memory cell, which acts as a memory unit capable of retaining information for an extended period. The memory cell is controlled by three gates: the input gate, the forget gate, and the output gate.

![LSTM](https://media.geeksforgeeks.org/wp-content/uploads/20230505122416/LSTM.png)

The input gate controls how much new information should be stored in the memory cell. The forget gate determines which information from the memory cell should be destroyed or forgotten. The output gate controls how much information is output from the memory cell to the next time step. These gates are controlled by activation functions, which are commonly sigmoid and tanh functions, and allow the LSTM to selectively update, forget, and output data from the memory cell.

### 39. What is the GRU model in NLP?

The [Gated Recurrent Unit (GRU)](https://www.geeksforgeeks.org/gated-recurrent-unit-networks/) model is a type of recurrent neural network (RNN) architecture that has been widely used in natural language processing (NLP) tasks. It is designed to address the vanishing gradient problem and capture long-term dependencies in sequential data.

GRU is similar to LSTM in that it incorporates gating mechanisms, but it has a simplified architecture with fewer gates, making it computationally more efficient and easier to train. The GRU model consists of the following components:

1. ***Hidden State:*** The hidden state ![h_{t-1}      ](https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-1b87ad94acd3b412ffefd76213d5aecb_l3.svg)in GRU represents the learned representation or memory of the input sequence up to the current time step. It retains and passes information from the past to the present.
2. ***Update Gate:*** The update gate in GRU controls the flow of information from the past hidden state to the current time step. It determines how much of the previous information should be retained and how much new information should be incorporated.
3. ***Reset Gate:*** The reset gate in GRU determines how much of the past information should be discarded or forgotten. It helps in removing irrelevant information from the previous hidden state.
4. ***Candidate Activation:*** The candidate activation represents the new information to be added to the hidden state ![h_{t}^{'}      ](https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-64927415759bb9e410eaf259d69d3aac_l3.svg). It is computed based on the current input and a transformed version of the previous hidden state using the reset gate.

![GRU-gated-recurrent-unit](https://media.geeksforgeeks.org/wp-content/uploads/20230725171026/Gated-Recurrent-Unit.webp)

GRU models have been effective in NLP applications like language modelling, sentiment analysis, machine translation, and text generation. They are particularly useful in situations when it is essential to capture long-term dependencies and understand the context. Due to its simplicity and computational efficiency, GRU makes it a popular choice in NLP research and applications.

### 40. What is the sequence-to-sequence (Seq2Seq) model in NLP?

[Sequence-to-sequence (Seq2Seq)](https://www.geeksforgeeks.org/seq2seq-model-in-machine-learning/) is a type of neural network that is used for natural language processing (NLP) tasks. It is a type of recurrent neural network (RNN) that can learn long-term word relationships. This makes it ideal for tasks like machine translation, text summarization, and question answering.

The model is composed of two major parts: an encoder and a decoder. Here’s how the Seq2Seq model works:

1. ***Encoder***: The encoder transforms the input sequence, such as a sentence in the source language, into a fixed-length vector representation known as the “context vector” or “thought vector”. To capture sequential information from the input, the encoder commonly employs recurrent neural networks (RNNs) such as Long Short-Term Memory (LSTM) or Gated Recurrent Units (GRU).
2. ***Context Vector:*** The encoder’s context vector acts as a summary or representation of the input sequence. It encodes the meaning and important information from the input sequence into a fixed-size vector, regardless of the length of the input.
3. ***Decoder***: The decoder uses the encoder’s context vector to build the output sequence, which could be a translation or a summarised version. It is another RNN-based network that creates the output sequence one token at a time. At each step, the decoder can be conditioned on the context vector, which serves as an initial hidden state.

During training, the decoder is fed ground truth tokens from the target sequence at each step. Backpropagation through time (BPTT) is a technique commonly used to train Seq2Seq models. The model is optimized to minimize the difference between the predicted output sequence and the actual target sequence.

The Seq2Seq model is used during prediction or generation to construct the output sequence word by word, with each predicted word given back into the model as input for the subsequent step. The process is repeated until either an end-of-sequence token or a predetermined maximum length is achieved.

### 41. How does the attention mechanism helpful in NLP?

An [attention mechanism](https://www.geeksforgeeks.org/ml-attention-mechanism/) is a kind of neural network that uses an additional attention layer within an Encoder-Decoder neural network that enables the model to focus on specific parts of the input while performing a task. It achieves this by dynamically assigning weights to different elements in the input, indicating their relative importance or relevance. This selective attention allows the model to focus on relevant information, capture dependencies, and analyze relationships within the data.

The attention mechanism is particularly valuable in tasks involving sequential or structured data, such as natural language processing or computer vision, where long-term dependencies and contextual information are crucial for achieving high performance. By allowing the model to selectively attend to important features or contexts, it improves the model’s ability to handle complex relationships and dependencies in the data, leading to better overall performance in various tasks.

### 42. What is the Transformer model?

[Transformer](https://www.geeksforgeeks.org/transformer-neural-network-in-deep-learning-overview/) is one of the fundamental models in NLP based on the attention mechanism, which allows it to capture long-range dependencies in sequences more effectively than traditional recurrent neural networks (RNNs). It has given state-of-the-art results in various NLP tasks like word embedding, machine translation, text summarization, question answering etc.

Some of the key advantages of using a Transformer are as follows:

- ***Parallelization***: The self-attention mechanism allows the model to process words in parallel, which makes it significantly faster to train compared to sequential models like RNNs.
- ***Long-Range Dependencies:*** The attention mechanism enables the Transformer to effectively capture long-range dependencies in sequences, which makes it suitable for tasks where long-term context is essential.
- ***State-of-the-Art Performance:*** Transformer-based models have achieved state-of-the-art performance in various NLP tasks, such as machine translation, language modelling, text generation, and sentiment analysis.

The key components of the Transformer model are as follows:

- Self-Attention Mechanism:
- Encoder-Decoder Network:
- Multi-head Attention:
- Positional Encoding
- Feed-Forward Neural Networks
- Layer Normalization and Residual Connections

### 43. What is the role of the self-attention mechanism in Transformers?

The [self-attention mechanism](https://www.geeksforgeeks.org/self-attention-in-nlp/) is a powerful tool that allows the Transformer model to capture long-range dependencies in sequences. It allows each word in the input sequence to attend to all other words in the same sequence, and the model learns to assign weights to each word based on its relevance to the others. This enables the model to capture both short-term and long-term dependencies, which is critical for many NLP applications.

### 44. What is the purpose of the multi-head attention mechanism in Transformers?

The purpose of the [multi-head attention mechanism](https://www.geeksforgeeks.org/ml-attention-mechanism/) in Transformers is to allow the model to recognize different types of correlations and patterns in the input sequence. In both the encoder and decoder, the Transformer model uses multiple attention heads. This enables the model to recognise different types of correlations and patterns in the input sequence. Each attention head learns to pay attention to different parts of the input, allowing the model to capture a wide range of characteristics and dependencies.

The multi-head attention mechanism helps the model in learning richer and more contextually relevant representations, resulting in improved performance on a variety of natural language processing (NLP) tasks.

### 45. What are positional encodings in Transformers, and why are they necessary?

The [transformer](https://www.geeksforgeeks.org/transformer-neural-network-in-deep-learning-overview/) model processes the input sequence in parallel, so that lacks the inherent understanding of word order like the sequential model recurrent neural networks (RNNs), LSTM possess. So, that. it requires a method to express the positional information explicitly. 

Positional encoding is applied to the input embeddings to offer this positional information like the relative or absolute position of each word in the sequence to the model. These encodings are typically learnt and can take several forms, including sine and cosine functions or learned embeddings. This enables the model to learn the order of the words in the sequence, which is critical for many NLP tasks.

### 46. Describe the architecture of the Transformer model.

The architecture of the Transformer model is based on self-attention and feed-forward neural network concepts. It is made up of an encoder and a decoder, both of which are composed of multiple layers, each containing self-attention and feed-forward sub-layers. The model’s design encourages parallelization, resulting in more efficient training and improved performance on tasks involving sequential data, such as natural language processing (NLP) tasks.

The architecture can be described in depth below:

1. ***Encoder***

   :

   - Input Embeddings: The encoder takes an input sequence of tokens (e.g., words) as input and transforms each token into a vector representation known as an embedding. Positional encoding is used in these embeddings to preserve the order of the words in the sequence.
   - Self-Attention Layers: An encoder consists of multiple self-attention layers and each self-attention layer is used to capture relationships and dependencies between words in the sequence.
   - Feed-Forward Layers: After the self-attention step, the output representations of the self-attention layer are fed into a feed-forward neural network. This network applies the non-linear transformations to each word’s contextualised representation independently.
   - Layer Normalization and Residual Connections: Residual connections and layer normalisation are used to back up the self-attention and feed-forward layers. The residual connections in deep networks help to mitigate the vanishing gradient problem, and layer normalisation stabilises the training process.

2. ***Decoder***

   :

   - Input Embeddings: Similar to the encoder, the decoder takes an input sequence and transforms each token into embeddings with positional encoding.
   - Masked Self-Attention: Unlike the encoder, the decoder uses masked self-attention in the self-attention layers. This masking ensures that the decoder can only attend to places before the current word during training, preventing the model from seeing future tokens during generation.
   - Cross-Attention Layers: Cross-attention layers in the decoder allow it to attend to the encoder’s output, which enables the model to use information from the input sequence during output sequence generation.
   - Feed-Forward Layers: Similar to the encoder, the decoder’s self-attention output passes through feed-forward neural networks.
   - Layer Normalization and Residual Connections: The decoder also includes residual connections and layer normalization to help in training and improve model stability.

3. **Final Output Layer:**

   - Softmax Layer: The final output layer is a softmax layer that transforms the decoder’s representations into probability distributions over the vocabulary. This enables the model to predict the most likely token for each position in the output sequence.

Overall, the Transformer’s architecture enables it to successfully handle long-range dependencies in sequences and execute parallel computations, making it highly efficient and powerful for a variety of sequence-to-sequence tasks. The model has been successfully used for machine translation, language modelling, text generation, question answering, and a variety of other NLP tasks, with state-of-the-art results.

### 47. What is the difference between a generative and discriminative model in NLP?

Both generative and discriminative models are the types of [machine learning](https://www.geeksforgeeks.org/machine-learning/) models used for different purposes in the field of natural language processing (NLP).

[Generative models](https://www.geeksforgeeks.org/the-difference-between-generative-and-discriminative-machine-learning-algorithms/) are trained to generate new data that is similar to the data that was used to train them.  For example, a generative model could be trained on a dataset of text and code and then used to generate new text or code that is similar to the text and code in the dataset. Generative models are often used for tasks such as text generation, machine translation, and creative writing.

[Discriminative models](https://www.geeksforgeeks.org/the-difference-between-generative-and-discriminative-machine-learning-algorithms/) are trained to recognise different types of data. A discriminative model. For example, a discriminative model could be trained on a dataset of labelled text and then used to classify new text as either spam or ham. Discriminative models are often used for tasks such as text classification, sentiment analysis, and question answering.

The key differences between generative and discriminative models in NLP are as follows:

|          |                      Generative Models                       |                    Discriminative Models                     |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| Purpose  |   Generate new data that is similar to the training data.    | Distinguish between different classes or categories of data. |
| Training | Learn the joint probability distribution of input and output data to generate new samples. | Learn the conditional probability distribution of the output labels given the input data. |
| Examples | Text generation, machine translation, creative writing, Chatbots, text summarization, and language modelling. | Text classification, sentiment analysis, and named entity recognition. |

### 48. What is machine translation, and how does it is performed?

[Machine translation](https://www.geeksforgeeks.org/machine-translation-of-languages-in-artificial-intelligence/) is the process of automatically translating text or speech from one language to another using a computer or machine learning model.

There are three techniques for machine translation:

- Rule-based machine translation (RBMT): RBMT systems use a set of rules to translate text from one language to another.
- Statistical machine translation (SMT): SMT systems use statistical models to calculate the probability of a given translation being correct.
- Neural machine translation (NMT): Neural machine translation (NMT) is a recent technique of machine translation have been proven to be more accurate than RBMT and SMT systems, In recent years, neural machine translation (NMT), powered by deep learning models such as the Transformer, are becoming increasingly popular.

### 49. What is the BLEU score?

[BLEU](https://www.geeksforgeeks.org/nlp-bleu-score-for-evaluating-neural-machine-translation-python/) stands for “Bilingual Evaluation Understudy”. It is a metric invented by IBM in 2001 for evaluating the quality of a machine translation. It measures the similarity between machine-generated translations with the professional human translation. It was one of the first metrics whose results are very much correlated with human judgement.

The BLEU score is measured by comparing the n-grams (sequences of n words) in the machine-translated text to the n-grams in the reference text. The higher BLEU Score signifies, that the machine-translated text is more similar to the reference text.

The BLEU (Bilingual Evaluation Understudy) score is calculated using n-gram precision and a brevity penalty.

- N-gram Precision: The n-gram precision is the ratio of matching n-grams in the machine-generated translation to the total number of n-grams in the reference translation. The number of unigrams, bigrams, trigrams, and four-grams (i=1,…,4) that coincide with their n-gram counterpart in the reference translations is measured by the n-gram overlap.
  ![\text{precision}_i = \frac{\text{Count of matching n-grams}}{\text{count of all n-grams in the machine translation}}      ](https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-175d3994ac3fb698aeadaa1501a5d103_l3.svg)
  For BLEU score ![\text{precision}_i      ](https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-36031c0397efb8f38662c07104ff17dd_l3.svg)is calculated for the I ranging (1 to N). Usually, the N value will be up to 4.
- Brevity Penalty: Brevity Penalty measures the length difference between machine-generated translations and reference translations. While finding the BLEU score, It penalizes the machine-generated translations if that is found too short compared to the reference translation’s length with exponential decay.
  ![\text{brevity-penalty} = \min{\left(1, \exp{\left(1-\frac{\text{Reference length}}{\text{Machine translation length)}}\right)}\right)}     ](https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-4e0d5b297c0f270b779a322795e9287f_l3.svg)
- BLEU Score: The BLEU score is calculated by taking the geometric mean of the individual n-gram precisions and then adjusting it with the brevity penalty.
  ![\begin{aligned} \text{BLEU} &= \text{brevity-penalty} \times \exp\left[\frac{\sum_{i=1}^{N} \log(\text{precision}_i)}{N}\right] \\&= \text{brevity-penalty} \times \exp\left[\frac{\log \left(\prod_{i=1}^{N} \text{precision}_i\right)}{N}\right] \\&= \text{brevity-penalty} \times \left(\prod_{i=1}^{N} \text{precision}_i\right)^{\frac{1}{N}} \end{aligned}      ](https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-1bda6eddc146d2baafc8a7deb263ca02_l3.svg)
  Here, N is the maximum n-gram size, (usually 4).

The BLEU score goes from 0 to 1, with higher values indicating better translation quality and 1 signifying a perfect match to the reference translation

### 50. List out the popular NLP task and their corresponding evaluation metrics.

Natural Language Processing (NLP) involves a wide range of tasks, each with its own set of objectives and evaluation criteria. Below is a list of common NLP tasks along with some typical evaluation metrics used to assess their performance:

|            Natural Language Processing(NLP) Tasks            |                   ***Evaluation Metric***                    |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| Part-of-Speech Tagging (POS Tagging) or Named Entity Recognition (NER) |            Accuracy, F1-score, Precision, Recall             |
|                      Dependency Parsing                      | UAS (Unlabeled Attachment Score), LAS (Labeled Attachment Score) |
|                    Coreference resolution                    |                      B-CUBED, MUC, CEAF                      |
|          Text Classification or Sentiment Analysis           |            Accuracy, F1-score, Precision, Recall             |
|                     Machine Translation                      | BLEU (Bilingual Evaluation Understudy), METEOR (Metric for Evaluation of Translation with Explicit Ordering) |
|                      Text Summarization                      | ROUGE (Recall-Oriented Understudy for Gisting Evaluation), BLEU |
|                      Question Answering                      |    F1-score, Precision, Recall, MRR(Mean Reciprocal Rank)    |
|                       Text Generation                        | Human evaluation (subjective assessment), perplexity (for language models) |
|                    Information Retrieval                     |  Precision, Recall, F1-score, Mean Average Precision (MAP)   |
|               Natural language inference (NLI)               | Accuracy, precision, recall, F1-score, Matthews correlation coefficient (MCC) |
|                        Topic Modeling                        |                 Coherence Score, Perplexity                  |
|                      Speech Recognition                      |                    Word Error Rate (WER)                     |
|              Speech Synthesis (Text-to-Speech)               |                   Mean Opinion Score (MOS)                   |

The brief explanations of each of the evaluation metrics are as follows:

- ***Accuracy***: Accuracy is the percentage of predictions that are correct.
- ***Precision***: Precision is the percentage of correct predictions out of all the predictions that were made.
- ***Recall***: Recall is the percentage of correct predictions out of all the positive cases.
- ***F1-score***: F1-score is the harmonic mean of precision and recall.
- ***MAP(Mean Average Precision)***: MAP computes the average precision for each query and then averages those precisions over all queries.
- ***MUC(Mention-based Understudy for Coreference)***: MUC is a metric for coreference resolution that measures the number of mentions that are correctly identified and linked.
- ***B-CUBED***: B-cubed is a metric for coreference resolution that measures the number of mentions that are correctly identified, linked, and ordered.
- ***CEAF***: CEAF is a metric for coreference resolution that measures the similarity between the predicted coreference chains and the gold standard coreference chains.
- ***ROC AUC:*** ROC AUC is a metric for binary classification that measures the area under the receiver operating characteristic curve.
- ***MRR***: MRR is a metric for question answering that measures the mean reciprocal rank of the top-k-ranked documents.
- ***Perplexity***: Perplexity is a language model evaluation metric. It assesses how well a linguistic model predicts a sample or test set of previously unseen data. Lower perplexity values suggest that the language model is more predictive.
- ***BLEU***: BLEU is a metric for machine translation that measures the n-gram overlap between the predicted translation and the gold standard translation.
- ***METEOR***: METEOR is a metric for machine translation that measures the overlap between the predicted translation and the gold standard translation, taking into account synonyms and stemming.
- ***WER(Word Error Rate)***: WER is a metric for machine translation that measures the word error rate of the predicted translation.
- ***MCC***: MCC is a metric for natural language inference that measures the Matthews correlation coefficient between the predicted labels and the gold standard labels.
- ***ROUGE***: ROUGE is a metric for text summarization that measures the overlap between the predicted summary and the gold standard summary, taking into account n-grams and synonyms.
- ***Human Evaluation (Subjective Assessment)***: Human experts or crowd-sourced workers are asked to submit their comments, evaluations, or rankings on many elements of the NLP task’s performance in this technique.